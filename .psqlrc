\pset linestyle unicode
\pset border 2
\pset null Â¤
\timing
\set PROMPT1 'user=%n,db=%/@%m:%>=%# '
\set HISTSIZE 5000
\set FETCH_COUNT 1000
\set HISTCONTROL ignoredups

\echo '\nCurrent Host Server Date Time : '`date` '\n'

\echo 'Administrative queries:\n'
\echo '\t\t\t:settings\t-- Server Settings'
\echo '\t\t\t:waits\t\t-- Waiting queries'
\echo '\t\t\t:locks\t\t-- Locking queries'
\echo '\t\t\t:blocking\t-- Blocking queries'
\echo '\t\t\t:ccount\t\t-- Connection count'
\echo '\t\t\t:userconn\t-- User connections info'
\echo '\t\t\t:idletrx\t-- IDLE in transaction queires'
\echo '\t\t\t:rsize\t\t-- Size of 20 biggest relations(tables)'
\echo '\t\t\t:tblbloat\t-- Table bloat'
\echo '\t\t\t:tblstorageprop\t-- Table storage prop'
\echo '\t\t\t:tblage\t\t-- Table age'
\echo '\t\t\t:vacuuminfo\t-- Vacuum info for all databases'
\echo '\t\t\t:avneeded\t-- Tables which needed vacuum'
\echo '\t\t\t:unusedindex\t-- Unused indexes'
\echo '\t\t\t:indexusage\t-- Index usage statistics'
\echo '\t\t\t:indexbloat\t-- Index bloating > 50MB and > 50% of table'
\echo '\t\t\t:indexbloatll\t-- Index bloating for all tables'
\echo '\t\t\t:indexdup\t-- Show duplicate index'
\echo '\t\t\t:uselesscol\t-- Useless columns'
\echo '\t\t\t:uptime\t\t-- Server uptime'
\echo '\t\t\t:menu\t\t-- Help Menu'
\echo '\t\t\t\\h\t\t-- Help with SQL commands'
\echo '\t\t\t\\?\t\t-- Help with psql commands\n'

\echo 'Development queries:\n'
\echo '\t\t\t:sp\t\t-- Current Search Path'
\echo '\t\t\t:clear\t\t-- Clear screen'

\set sp 'SHOW search_path;'
\set clear '\\! clear;'

\set uptime 'SELECT now() - pg_postmaster_start_time() AS uptime;'

\set menu '\\i ~/.psqlrc'

\set settings 'SELECT name, setting, unit, context FROM pg_settings;'

\set waits 'SELECT pid, query, waiting, now() - query_start  as "totaltime", backend_start FROM pg_stat_activity WHERE query !~ \'.*?IDLE.*?\'::text AND waiting;'

\set locks 'SELECT a.pid,mode,query FROM pg_locks l ,pg_stat_activity a WHERE NOT granted AND locktype=\'transactionid\' AND l.pid=a.pid ORDER BY psa.pid,granted;'

\set blocking 'SELECT bl.pid AS blocked_pid, a.usename AS blocked_user, ka.query AS blocking_statement, now() - ka.query_start AS blocking_duration, kl.pid AS blocking_pid, ka.usename AS blocking_user, a.query AS blocked_statement, now() - a.query_start  AS blocked_duration FROM  pg_catalog.pg_locks bl JOIN pg_catalog.pg_stat_activity a ON a.pid = bl.pid JOIN pg_catalog.pg_locks kl ON kl.transactionid = bl.transactionid AND kl.pid != bl.pid JOIN pg_catalog.pg_stat_activity ka ON ka.pid = kl.pid WHERE NOT bl.granted;'

\set ccount 'SELECT count(*) as totalconnections FROM pg_stat_activity;'

\set unusedindex 'WITH table_scans AS (  SELECT relid   ,tables.idx_scan + tables.seq_scan AS all_scans   ,(tables.n_tup_ins + tables.n_tup_upd + tables.n_tup_del) AS writes   ,pg_relation_size(relid) AS table_size  FROM pg_stat_user_tables AS tables  )  ,all_writes AS (  SELECT sum(writes) AS total_writes  FROM table_scans  )  ,indexes AS (  SELECT idx_stat.relid   ,idx_stat.indexrelid   ,idx_stat.schemaname   ,idx_stat.relname AS tablename   ,idx_stat.indexrelname AS indexname   ,idx_stat.idx_scan   ,pg_relation_size(idx_stat.indexrelid) AS index_bytes   ,indexdef ~* \'USING btree\' AS idx_is_btree  FROM pg_stat_user_indexes AS idx_stat  JOIN pg_index USING (indexrelid)  JOIN pg_indexes AS indexes ON idx_stat.schemaname = indexes.schemaname   AND idx_stat.relname = indexes.tablename   AND idx_stat.indexrelname = indexes.indexname  WHERE pg_index.indisunique = FALSE  )  ,index_ratios AS (  SELECT schemaname   ,tablename   ,indexname   ,idx_scan   ,all_scans   ,round((     CASE      WHEN all_scans = 0       THEN 0.0::NUMERIC      ELSE idx_scan::NUMERIC / all_scans * 100      END     ), 2) AS index_scan_pct   ,writes   ,round((     CASE      WHEN writes = 0       THEN idx_scan::NUMERIC      ELSE idx_scan::NUMERIC / writes      END     ), 2) AS scans_per_write   ,pg_size_pretty(index_bytes) AS index_size   ,pg_size_pretty(table_size) AS table_size   ,idx_is_btree   ,index_bytes  FROM indexes  JOIN table_scans USING (relid)  )  ,index_groups AS (  SELECT \'Never Used Indexes\' AS reason   ,*   ,1 AS grp  FROM index_ratios  WHERE idx_scan = 0   AND idx_is_btree   UNION ALL   SELECT \'Low Scans, High Writes\' AS reason   ,*   ,2 AS grp  FROM index_ratios  WHERE scans_per_write <= 1   AND index_scan_pct < 10   AND idx_scan > 0   AND writes > 100   AND idx_is_btree   UNION ALL   SELECT \'Seldom Used Large Indexes\' AS reason   ,*   ,3 AS grp  FROM index_ratios  WHERE index_scan_pct < 5   AND scans_per_write > 1   AND idx_scan > 0   AND idx_is_btree   AND index_bytes > 100000000   UNION ALL   SELECT \'High-Write Large Non-Btree\' AS reason   ,index_ratios.*   ,4 AS grp  FROM index_ratios   ,all_writes  WHERE (writes::NUMERIC / (total_writes + 1)) > 0.02   AND NOT idx_is_btree   AND index_bytes > 100000000  ORDER BY grp   ,index_bytes DESC  ) SELECT reason  ,schemaname  ,tablename  ,indexname  ,index_scan_pct  ,scans_per_write  ,index_size  ,table_size FROM index_groups;'

\set userconn 'SELECT count(*) AS connections ,client_addr::TEXT FROM pg_stat_activity GROUP BY client_addr;'

\set idletrx  'SELECT pid, datname, usename, client_addr, backend_start, waiting, query FROM pg_stat_activity WHERE query ~ \'.*?<IDLE> in transaction\'::text;'

\set rsize 'SELECT nspname || \'.\' || relname AS "relation" ,pg_size_pretty(pg_total_relation_size(C.oid)) AS "total_size" FROM pg_class C LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace) WHERE nspname NOT IN ( \'pg_catalog\' ,\'information_schema\') AND C.relkind <> \'i\' AND nspname !~ \'^pg_toast\' ORDER BY pg_total_relation_size(C.oid) DESC LIMIT 20;'

\set indexusage 'SELECT t.tablename  ,indexname  ,c.reltuples AS num_rows  ,pg_size_pretty(pg_relation_size((quote_ident(t.schemaname) || \'.\' || quote_ident(t.tablename))::TEXT)) AS table_size  ,pg_size_pretty(pg_relation_size((quote_ident(foo.schemaname) || \'.\' || quote_ident(indexrelname))::TEXT)) AS index_size  ,CASE   WHEN indisunique    THEN \'Y\'   ELSE \'N\'   END AS UNIQUE  ,idx_scan AS number_of_scans  ,idx_tup_read AS tuples_read  ,idx_tup_fetch AS tuples_fetched FROM pg_tables t LEFT OUTER JOIN pg_class c ON t.tablename = c.relname LEFT OUTER JOIN (  SELECT c.relname AS ctablename   ,ipg.relname AS indexname   ,psai.schemaname   ,x.indnatts AS number_of_columns   ,idx_scan   ,idx_tup_read   ,idx_tup_fetch   ,indexrelname   ,indisunique  FROM pg_index x  JOIN pg_class c ON c.oid = x.indrelid  JOIN pg_class ipg ON ipg.oid = x.indexrelid  JOIN pg_stat_all_indexes psai ON x.indexrelid = psai.indexrelid  ) AS foo ON t.tablename = foo.ctablename WHERE t.schemaname NOT IN (   \'informational_schema\'   ,\'pg_catalog\'   ) ORDER BY 1  ,2;'

\set indexbloat 'WITH btree_index_atts AS (  SELECT nspname   ,relname   ,reltuples   ,relpages   ,indrelid   ,relam   ,regexp_split_to_table(indkey::TEXT, \' \')::SMALLINT AS attnum   ,indexrelid AS index_oid  FROM pg_index  JOIN pg_class ON pg_class.oid = pg_index.indexrelid  JOIN pg_namespace ON pg_namespace.oid = pg_class.relnamespace  JOIN pg_am ON pg_class.relam = pg_am.oid  WHERE pg_am.amname = \'btree\'  )  ,index_item_sizes AS (  SELECT i.nspname   ,i.relname   ,i.reltuples   ,i.relpages   ,i.relam   ,s.starelid   ,a.attrelid AS table_oid   ,index_oid   ,current_setting(\'block_size\')::NUMERIC AS bs   ,   /* MAXALIGN: 4 on 32bits, 8 on 64bits (and mingw32 ?) */   CASE    WHEN version() ~ \'mingw32\'     OR version() ~ \'64-bit\'     THEN 8    ELSE 4    END AS maxalign   ,24 AS pagehdr   ,   /* per tuple header: add index_attribute_bm if some cols are null-able */   CASE    WHEN max(coalesce(s.stanullfrac, 0)) = 0     THEN 2    ELSE 6    END AS index_tuple_hdr   ,   /* data len: we remove null values save space using it fractionnal part from stats */   sum((1 - coalesce(s.stanullfrac, 0)) * coalesce(s.stawidth, 2048)) AS nulldatawidth  FROM pg_attribute AS a  JOIN pg_statistic AS s ON s.starelid = a.attrelid   AND s.staattnum = a.attnum  JOIN btree_index_atts AS i ON i.indrelid = a.attrelid   AND a.attnum = i.attnum  WHERE a.attnum > 0  GROUP BY 1   ,2   ,3   ,4   ,5   ,6   ,7   ,8   ,9  )  ,index_aligned AS (  SELECT maxalign   ,bs   ,nspname   ,relname AS index_name   ,reltuples   ,relpages   ,relam   ,table_oid   ,index_oid   ,(    2 + maxalign - CASE /* Add padding to the index tuple header to align on MAXALIGN */     WHEN 2 % maxalign = 0      THEN maxalign     ELSE 2 % maxalign     END + nulldatawidth + maxalign - CASE /* Add padding to the data to align on MAXALIGN */     WHEN nulldatawidth::INTEGER % maxalign = 0      THEN maxalign     ELSE nulldatawidth::INTEGER % maxalign     END    )::NUMERIC AS nulldatahdrwidth   ,pagehdr  FROM index_item_sizes AS s1  )  ,otta_calc AS (  SELECT bs   ,nspname   ,table_oid   ,index_oid   ,index_name   ,relpages   ,coalesce(ceil((reltuples * (4 + nulldatahdrwidth)) / (bs - pagehdr::FLOAT)) + CASE     WHEN am.amname IN (       \'hash\'       ,\'btree\'       )      THEN 1     ELSE 0     END, 0 /* btree and hash have a metadata reserved block */   ) AS otta  FROM index_aligned AS s2  LEFT JOIN pg_am am ON s2.relam = am.oid  )  ,raw_bloat AS (  SELECT current_database() AS dbname   ,nspname   ,c.relname AS table_name   ,index_name   ,bs * (sub.relpages)::BIGINT AS totalbytes   ,CASE    WHEN sub.relpages <= otta     THEN 0    ELSE bs * (sub.relpages - otta)::BIGINT    END AS wastedbytes   ,CASE    WHEN sub.relpages <= otta     THEN 0    ELSE bs * (sub.relpages - otta)::BIGINT * 100 / (bs * (sub.relpages)::BIGINT)    END AS realbloat   ,pg_relation_size(sub.table_oid) AS table_bytes   ,stat.idx_scan AS index_scans  FROM otta_calc AS sub  JOIN pg_class AS c ON c.oid = sub.table_oid  JOIN pg_stat_user_indexes AS stat ON sub.index_oid = stat.indexrelid  ) SELECT dbname AS database_name  ,nspname AS schema_name  ,table_name  ,index_name  ,round(realbloat, 1) AS bloat_pct  ,wastedbytes AS bloat_bytes  ,pg_size_pretty(wastedbytes::BIGINT) AS bloat_size  ,totalbytes AS index_bytes  ,pg_size_pretty(totalbytes::BIGINT) AS index_size  ,table_bytes  ,pg_size_pretty(table_bytes::BIGINT) AS table_size  ,index_scans FROM raw_bloat WHERE (   realbloat > 50   AND wastedbytes > 50000000   ) ORDER BY wastedbytes DESC;'

\set indexbloatall 'SELECT current_database()  ,nspname AS schemaname  ,tblname  ,idxname  ,bs * (sub.relpages)::BIGINT AS real_size  ,bs * est_pages::BIGINT AS estimated_size  ,bs * (sub.relpages - est_pages)::BIGINT AS bloat_size  ,100 * (sub.relpages - est_pages)::FLOAT / sub.relpages AS bloat_ratio  ,is_na FROM (  SELECT bs   ,nspname   ,table_oid   ,tblname   ,idxname   ,relpages   ,coalesce(1 + ceil(reltuples / floor((bs - pageopqdata - pagehdr) / (4 + nulldatahdrwidth)::FLOAT)), 0   ) AS est_pages   ,is_na  FROM (   SELECT maxalign    ,bs    ,nspname    ,tblname    ,idxname    ,reltuples    ,relpages    ,relam    ,table_oid    ,(     index_tuple_hdr_bm + maxalign - CASE      WHEN index_tuple_hdr_bm % maxalign = 0       THEN maxalign      ELSE index_tuple_hdr_bm % maxalign      END + nulldatawidth + maxalign - CASE      WHEN nulldatawidth = 0       THEN 0      WHEN nulldatawidth::INTEGER % maxalign = 0       THEN maxalign      ELSE nulldatawidth::INTEGER % maxalign      END     )::NUMERIC AS nulldatahdrwidth    ,pagehdr    ,pageopqdata    ,is_na   FROM (    SELECT i.nspname     ,i.tblname     ,i.idxname     ,i.reltuples     ,i.relpages     ,i.relam     ,a.attrelid AS table_oid     ,current_setting(\'block_size\')::NUMERIC AS bs     ,CASE      WHEN version() ~ \'mingw32\'       OR version() ~ \'64-bit|x86_64|ppc64|ia64|amd64\'       THEN 8      ELSE 4      END AS maxalign     ,     24 AS pagehdr     ,     16 AS pageopqdata     ,     CASE      WHEN max(coalesce(s.null_frac, 0)) = 0       THEN 2      ELSE 2 + ((32 + 8 - 1) / 8)      END AS index_tuple_hdr_bm     ,     sum((1 - coalesce(s.null_frac, 0)) * coalesce(s.avg_width, 1024)) AS nulldatawidth     ,max(CASE       WHEN a.atttypid = \'pg_catalog.name\'::regtype        THEN 1       ELSE 0       END) > 0 AS is_na    FROM pg_attribute AS a    JOIN (     SELECT nspname      ,tbl.relname AS tblname      ,idx.relname AS idxname      ,idx.reltuples      ,idx.relpages      ,idx.relam      ,indrelid      ,indexrelid      ,indkey::SMALLINT [] AS attnum     FROM pg_index     JOIN pg_class idx ON idx.oid = pg_index.indexrelid     JOIN pg_class tbl ON tbl.oid = pg_index.indrelid     JOIN pg_namespace ON pg_namespace.oid = idx.relnamespace     WHERE pg_index.indisvalid      AND tbl.relkind = \'r\'      AND pg_namespace.nspname NOT IN (       \'information_schema\'       ,\'pg_catalog\'       )     ) AS i ON a.attrelid = i.indexrelid    JOIN pg_stats AS s ON s.schemaname = i.nspname     AND (      (       s.tablename = i.tblname       AND s.attname = pg_catalog.pg_get_indexdef(a.attrelid, a.attnum, TRUE)       )      OR (       s.tablename = i.idxname       AND s.attname = a.attname       )      )    JOIN pg_type AS t ON a.atttypid = t.oid    WHERE a.attnum > 0    GROUP BY 1     ,2     ,3     ,4     ,5     ,6     ,7     ,8     ,9    ) AS s1   ) AS s2  JOIN pg_am am ON s2.relam = am.oid  WHERE am.amname = \'btree\'  ) AS sub ORDER BY 2  ,3  ,4;'

\set tblbloat 'SELECT current_database()  ,schemaname  ,tblname  ,bs * tblpages AS real_size  ,(tblpages - est_num_pages) * bs AS bloat_size  ,tblpages  ,is_na  ,CASE   WHEN tblpages - est_num_pages > 0    THEN 100 * (tblpages - est_num_pages) / tblpages::FLOAT   ELSE 0   END AS bloat_ratio FROM (  SELECT ceil(reltuples / ((bs - page_hdr) / tpl_size)) + ceil(toasttuples / 4) AS est_num_pages   ,tblpages   ,bs   ,tblid   ,schemaname   ,tblname   ,heappages   ,toastpages   ,is_na  FROM (   SELECT (     4 + tpl_hdr_size + tpl_data_size + (2 * ma) - CASE      WHEN tpl_hdr_size % ma = 0       THEN ma      ELSE tpl_hdr_size % ma      END - CASE      WHEN ceil(tpl_data_size)::INT % ma = 0       THEN ma      ELSE ceil(tpl_data_size)::INT % ma      END     ) AS tpl_size    ,bs - page_hdr AS size_per_block    ,(heappages + toastpages) AS tblpages    ,heappages    ,toastpages    ,reltuples    ,toasttuples    ,bs    ,page_hdr    ,tblid    ,schemaname    ,tblname    ,is_na   FROM (    SELECT tbl.oid AS tblid     ,ns.nspname AS schemaname     ,tbl.relname AS tblname     ,tbl.reltuples     ,tbl.relpages AS heappages     ,coalesce(toast.relpages, 0) AS toastpages     ,coalesce(toast.reltuples, 0) AS toasttuples     ,current_setting(\'block_size\')::NUMERIC AS bs     ,CASE      WHEN version() ~ \'mingw32\'       OR version() ~ \'64-bit|x86_64|ppc64|ia64|amd64\'       THEN 8      ELSE 4      END AS ma     ,24 AS page_hdr     ,23 + CASE      WHEN MAX(coalesce(null_frac, 0)) > 0       THEN (7 + count(*)) / 8      ELSE 0::INT      END + CASE      WHEN tbl.relhasoids       THEN 4      ELSE 0      END AS tpl_hdr_size     ,sum((1 - coalesce(s.null_frac, 0)) * coalesce(CASE        WHEN t.typlen = - 1         THEN CASE           WHEN s.avg_width < 127            THEN s.avg_width + 1           ELSE s.avg_width + 4           END        WHEN t.typlen = - 2         THEN s.avg_width + 1        ELSE t.typlen        END, 1024)) AS tpl_data_size     ,bool_or(att.atttypid = \'pg_catalog.name\'::regtype) AS is_na    FROM pg_attribute AS att    JOIN pg_type AS t ON att.atttypid = t.oid    JOIN pg_class AS tbl ON att.attrelid = tbl.oid    JOIN pg_namespace AS ns ON ns.oid = tbl.relnamespace    JOIN pg_stats AS s ON s.schemaname = ns.nspname     AND s.tablename = tbl.relname     AND s.inherited = false     AND s.attname = att.attname    LEFT JOIN pg_class AS toast ON tbl.reltoastrelid = toast.oid    WHERE att.attnum > 0     AND NOT att.attisdropped     AND tbl.relkind = \'r\'     AND ns.nspname NOT IN (      \'information_schema\'      ,\'pg_catalog\'      )    GROUP BY 1     ,2     ,3     ,4     ,5     ,6     ,7     ,8     ,9     ,10     ,tbl.relhasoids    ORDER BY 2     ,3    ) AS s   ) AS s2  ) AS s3;'

\set tblstorageprop 'SELECT n.nspname  ,c.relname  ,pg_catalog.array_to_string(c.reloptions || array(SELECT \'toast.\' || x FROM pg_catalog.unnest(tc.reloptions) x), \', \') AS relopts FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_class tc ON (c.reltoastrelid = tc.oid) JOIN pg_namespace n ON c.relnamespace = n.oid  AND n.nspname NOT IN (   \'information_schema\'   ,\'pg_catalog\'   ) WHERE c.relkind = \'r\';'

\set tblage 'SELECT c.oid::regclass AS table_name  ,greatest(age(c.relfrozenxid), age(t.relfrozenxid)) AS age FROM pg_class c JOIN pg_namespace n ON c.relnamespace = n.oid  AND n.nspname NOT IN (   \'information_schema\'   ,\'pg_catalog\'   ) LEFT JOIN pg_class t ON c.reltoastrelid = t.oid WHERE c.relkind = \'r\';'

\set vacuuminfo 'SELECT datname, age(datfrozenxid) FROM pg_database;'

\set uselesscol 'SELECT nspname  ,relname  ,attname  ,typname  ,(stanullfrac * 100)::INT AS null_percent  ,CASE   WHEN stadistinct >= 0    THEN stadistinct   ELSE abs(stadistinct) * reltuples   END AS \"distinct\"  ,CASE 1   WHEN stakind1    THEN stavalues1   WHEN stakind2    THEN stavalues2   END AS \"values\" FROM pg_class c JOIN pg_namespace ns ON (ns.oid = relnamespace) JOIN pg_attribute ON (c.oid = attrelid) JOIN pg_type t ON (t.oid = atttypid) JOIN pg_statistic ON (   c.oid = starelid   AND staattnum = attnum   ) WHERE nspname NOT IN (\'information_schema\', \'pg_catalog\')  AND relkind = \'r\'  AND NOT attisdropped  AND attstattarget != 0  AND reltuples >= 100  AND stadistinct BETWEEN 0   AND 1 ORDER BY nspname  ,relname  ,attname;'

\set avneeded 'SELECT *  ,n_dead_tup > av_threshold AS "av_needed"  ,CASE   WHEN reltuples > 0    THEN round(100.0 * n_dead_tup / (reltuples))   ELSE 0   END AS pct_dead FROM (  SELECT N.nspname   ,C.relname   ,pg_stat_get_tuples_inserted(C.oid) AS n_tup_ins   ,pg_stat_get_tuples_updated(C.oid) AS n_tup_upd   ,pg_stat_get_tuples_deleted(C.oid) AS n_tup_del   ,pg_stat_get_live_tuples(C.oid) AS n_live_tup   ,pg_stat_get_dead_tuples(C.oid) AS n_dead_tup   ,C.reltuples AS reltuples   ,round(current_setting(\'autovacuum_vacuum_threshold\')::INTEGER + current_setting(\'autovacuum_vacuum_scale_factor\')::NUMERIC * C.reltuples) AS av_threshold   ,date_trunc(\'minute\', greatest(pg_stat_get_last_vacuum_time(C.oid), pg_stat_get_last_autovacuum_time(C.oid))) AS last_vacuum   ,date_trunc(\'minute\', greatest(pg_stat_get_last_analyze_time(C.oid), pg_stat_get_last_analyze_time(C.oid))) AS last_analyze  FROM pg_class C  LEFT JOIN pg_namespace N ON (N.oid = C.relnamespace)  WHERE C.relkind IN (    \'r\'    ,\'t\'    )   AND N.nspname NOT IN (    \'pg_catalog\'    ,\'information_schema\'    )   AND N.nspname !~ \'^pg_toast\'  ) AS av ORDER BY av_threshold DESC, av_needed DESC  ,n_dead_tup DESC;'

\set indexdup 'WITH index_cols_ord as (     SELECT attrelid, attnum, attname     FROM pg_attribute         JOIN pg_index ON indexrelid = attrelid     WHERE indkey[0] > 0     ORDER BY attrelid, attnum ), index_col_list AS (     SELECT attrelid,         array_agg(attname) as cols     FROM index_cols_ord     GROUP BY attrelid ), dup_natts AS ( SELECT indrelid, indexrelid FROM pg_index as ind WHERE EXISTS ( SELECT 1     FROM pg_index as ind2     WHERE ind.indrelid = ind2.indrelid     AND ( ind.indkey @> ind2.indkey      OR ind.indkey <@ ind2.indkey )     AND ind.indkey[0] = ind2.indkey[0]     AND ind.indkey <> ind2.indkey     AND ind.indexrelid <> ind2.indexrelid ) ) SELECT userdex.schemaname as schema_name,     userdex.relname as table_name,     userdex.indexrelname as index_name,     array_to_string(cols, \', \') as index_cols,     indexdef,     idx_scan as index_scans FROM pg_stat_user_indexes as userdex     JOIN index_col_list ON index_col_list.attrelid = userdex.indexrelid     JOIN dup_natts ON userdex.indexrelid = dup_natts.indexrelid     JOIN pg_indexes ON userdex.schemaname = pg_indexes.schemaname         AND userdex.indexrelname = pg_indexes.indexname ORDER BY userdex.schemaname, userdex.relname, cols, userdex.indexrelname;'
